#!/usr/bin/ruby

require 'debci'
require 'debci/html'
require 'debci/graph'

writer = Debci::HTML.new(File.join(Debci.config.data_basedir, '.html'))

if Dir["#{Debci.config.data_basedir}/*"].empty?
  writer.index('index.html')
  abort
end

writer.index('index.html')
writer.status('status/index.html')

repository = Debci::Repository.new

# Generate a JSON file for storing the current suite/architectures that are
# available. The file is used for the JavaScript data charts.
platform_writer = File.open(File.join(Debci.config.data_basedir, '.html/status', 'platforms.json'), 'w')
platforms = []

repository.suites.each do |suite|
  repository.architectures.each do |arch|
    platforms.push("platform" => suite + '/' + arch) if repository.status_history(suite, arch)
  end
end

platform_writer.write(JSON.pretty_generate(platforms))
platform_writer.close

packages = ARGV
if packages.empty?
  packages = repository.packages
end

prefixes = Set.new

packages.each do |pkg|
  package = repository.find_package(pkg)
  writer.package(package, "packages/#{package.prefix}/#{package.name}/index.html")
  package.suites.each do |suite|
    package.architectures.each do |arch|
      writer.history(package, suite, arch, "packages/#{package.prefix}/#{package.name}/#{suite}/#{arch}/index.html")
    end
  end
  prefixes << package.prefix
end


# Maintain a JSON file for storing a package's suite/architectures and
# status. The file is used for the JavaScript package search.
json_filename = File.join(Debci.config.data_basedir, '.html/packages', 'packages.json')
if File.exist?(json_filename)
  json_package_data = JSON.load(File.read(json_filename))
else
  json_package_data = []
end

packages.each do |pkg|
  package = repository.find_package(pkg)

  platforms = []

  package.suites.each do |suite|
    package.architectures.each do |arch|
      begin
        if package.history(suite, arch)
          platforms.push("#{suite}/#{arch}")
        end
      rescue JSON::ParserError
        puts "[ERROR] #{package.name} <#{suite}/#{arch}> history: Could not parse JSON"
      end
    end
  end

  all_statuses = []

  package.status.each do |row|
    row.each do |status|
      all_statuses.push(status.status) if status.status != :no_test_data
    end
  end
  entry = json_package_data.find { |entry| entry['package'] == pkg }
  if !entry
    entry = { 'package' => pkg }
    json_package_data.push(entry)
  end
  entry['platforms'] = platforms
  entry['status'] = all_statuses
end
File.open(json_filename, 'w') do |f|
  f.write(JSON.pretty_generate(json_package_data))
end

writer.prefix(nil, "packages/index.html")

prefixes.each do |p|
  writer.prefix(p, "packages/#{p}/index.html")
end
