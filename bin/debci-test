#!/bin/sh

short_options='r:'
long_options='reason:'

usage() {
  cat <<EOF
usage: debci-test [OPTIONS] srcpkg

Options:
  -r FILE, --reason FILE    add FILE contents to log as reason to run this test

$@
EOF
}

set -eu

debci_base_dir=$(readlink -f $(dirname $(readlink -f $0))/..)
. $debci_base_dir/lib/environment.sh
. $debci_base_dir/lib/functions.sh

global_tmp_dir=$(mktemp -d)
cleanup() {
  if [ -d "$global_tmp_dir" ]; then
    rm -rf "$global_tmp_dir"
  fi
}
trap cleanup INT TERM EXIT

process_package() {
  # setup tmp dir
  tmp_dir="$global_tmp_dir/$pkg"
  mkdir "$tmp_dir"

  # setup status "DB"
  status_dir=$(status_dir_for_package "$pkg")
  mkdir -p "$status_dir"

  last_status=$($debci_bin_dir/debci-status "$pkg")

  # output directory for test-package/adt-run
  run_id=$(date +%Y%m%d_%H%M%S)
  adt_out_dir="$(autopkgtest_dir_for_package "$pkg")/$run_id"
  mkdir -p "$adt_out_dir"
  status_file="${status_dir}/${run_id}.json"
  log_file="${status_dir}/${run_id}.log"

  do_process_package > "$log_file" 2>&1
  report_status "$pkg" "${status:-skip}"

  if [ -s "$log_file" ]; then
    # we actually ran, update "latest" links
    ln -sf "${run_id}.log" "${status_dir}/latest.log"
    ln -sf "${run_id}.json" "${status_dir}/latest.json"
    rm -f "${status_dir}/latest-autopkgtest"
    # generate relative symlink for relocatability
    ln -s "../../..${adt_out_dir#$debci_data_dir}" "${status_dir}/latest-autopkgtest"
  fi
}

do_process_package() {
  check_platform
  check_reason

  banner "Started: $(date -R)"

  start_time=$(date +%s)

  set +e
  test-package "$pkg" "$adt_out_dir"
  exit_status=$?
  set -e

  # ref: adt-run(1)
  case "$exit_status" in
    0)
      status=pass
      message='All tests passed'
      ;;
    2)
      status=pass
      message='Tests passed, but at least one test skipped'
      ;;
    4)
      status=fail
      message='Tests failed'
      ;;
    6)
      status=fail
      message='Tests failed, and at least one test skipped'
      ;;
    *)
      status=tmpfail
      message='Could not run tests due to a temporary failure'
      ;;
  esac
  finish_time=$(date +%s)
  duration=$(($finish_time - $start_time))

  check_dependencies
  check_base_system
  check_blame

  banner "Finished: $(date -R)"
  echo "∙ Status: $status ($message)"
  record_status
}

check_base_system() {

  if [ ! -e "$adt_out_dir/testbed-packages" ]; then
    return 0
  fi

  if [ -f "${status_dir}/latest-autopkgtest/testbed-packages" ]; then
    if ! diff -u \
      --label previous-run/testbed-packages "${status_dir}/latest-autopkgtest/testbed-packages" \
      --label current-run/testbed-packages "${adt_out_dir}/testbed-packages" \
        > "${tmp_dir}/base.diff"; then
      banner "Change in the base system since last run"
      cat "${tmp_dir}/base.diff"
    fi
  fi

  banner "Base system"
  cat "${adt_out_dir}/testbed-packages"
}

check_dependencies() {
  deps=$(cat $adt_out_dir/*t-*-packages | sort -u)

  if [ -n "$deps" ]; then
    banner "Test dependencies"
    echo "$deps"
    if [ -d ${status_dir}/latest-autopkgtest ]; then
      cat ${status_dir}/latest-autopkgtest/*t-*-packages | sort -u > $tmp_dir/last_test_packages
      if [ -s "$tmp_dir/last_test_packages" ]; then
        if ! echo "$deps" | diff -u --label last-run/test-packages "$tmp_dir/last_test_packages" --label current-run/test-packages - > "$tmp_dir/test-packages.diff"; then
          banner "Change in test packages for $pkg since last test run"
          cat "$tmp_dir/test-packages.diff"
        fi
      fi
    fi
  fi
}

check_platform() {
    banner "Platform information"
    echo "Package versions:"
    dpkg-query --show debci autopkgtest | indent
    echo "Backend: $debci_backend"
}

check_reason() {
  if [ -s "$cmdline_reason" ]; then
    banner "Triggers for test run"
    cat "$cmdline_reason"
  fi
}

check_blame() {
  blame="$(debci-status --field blame --json "$pkg")"
  if [ "$blame" = 'unknown' ]; then
    blame='[]'
  fi

  diff="${tmp_dir}/test-packages.diff"
  previous_diff="${status_dir}/test-packages.diff"

  if [ ! -e "$diff" ]; then
    return
  fi

  case "$status" in
    pass)
      blame='[]'
      ;;
    fail)
      case "${last_status}" in
        pass)
          # identify the packages to be blamed
          blame="$(debci-blame "${diff}" "$pkg")"
          ;;
        fail)
          # update versions from the blamed packages, but not include new
          # packages in the blame list. the file pointed to by $previous_diff
          # is guaranteed to exit at this point
          if [ -e "${previous_diff}" ]; then
            blamed_pkgs="$(debci-status --field blame "$pkg" | awk '{print($1)}')"
            combinediff "${previous_diff}" "${diff}" > "${diff}.new"
            mv "${diff}.new" "${diff}"
            blame=$(debci-blame "${diff}" "$pkg" $blamed_pkgs)
          fi
          ;;
      esac
      ;;
  esac

  if [ -f "${diff}" ]; then
    # record dependency chain diff from now to be used in future runs
    cp "${diff}" "${previous_diff}"
  fi
}

record_status() {
  if [ -e "$adt_out_dir/testpkg-version" ]; then
      version=$(cut -f2 -d' ' "$adt_out_dir/testpkg-version")
  else
      # test did not run, or backend forgets --output-dir
      version="n/a"
  fi

  hours=$(( $duration / 3600 ))
  minutes=$(( ($duration % 3600) / 60 ))
  seconds=$(( $duration - ($hours * 3600) - ($minutes * 60) ))
  duration_human="${hours}h ${minutes}m ${seconds}s"

  echo "∙ Duration: ${duration_human}"

  local previous_status="${last_status}"
  if [ "${previous_status}" = 'tmpfail' ]; then
    previous_status=$(debci-status --field previous_status "$pkg")
  fi

  # latest entry
  cat > "${status_file}" <<EOF
{
  "run_id": "${run_id}",
  "package": "${pkg}",
  "version": "${version}",
  "date": "$(date --rfc-3339=seconds)",
  "status": "${status}",
  "blame": $blame,
  "previous_status": "${previous_status}",
  "duration_seconds": "${duration}",
  "duration_human": "${duration_human}",
  "message": "${message}"
}
EOF

  # TODO cleanup old entries (?)

  # history
  history_file="$tmp_dir/history.json"
  echo '[' > "$history_file"
  sep=''
  entries=$(
    find "$status_dir" -name '*.json' \
      -and -not -name latest.json \
      -and -not -name history.json \
      | sort -Vr
  )
  for entry in $entries; do
    if [ -n "$sep" ]; then
      echo "$sep" >> "$history_file"
    fi
    sep=,
    cat $entry >> "$history_file"
  done
  echo ']' >> "$history_file"
  cp "$history_file" "$status_dir/history.json"
}

# defaults
cmdline_reason=''

while true; do
  case "$1" in
    -r|--reason)
      shift
      cmdline_reason="$1"
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      shift
      ;;
  esac
done

if [ $# -eq 1 ]; then
  pkg="$1"
  process_package
else
  echo "usage: $0 [OPTIONS] PACKAGE"
  exit 1
fi
