#!/bin/sh

set -e

base=$(readlink -f $(dirname $(readlink -f $0))/..)
. $base/lib/environment.sh
. $base/lib/functions.sh

run_id=$(date --rfc-3339=date)

global_tmp_dir=$(mktemp -d)
cleanup() {
  if [ -d "$global_tmp_dir" ]; then
    rm -rf "$global_tmp_dir"
  fi
}
trap cleanup INT TERM EXIT

one_month_ago="${global_tmp_dir}/one_month_ago"
touch -d '1 month ago' "${one_month_ago}"

process_package() {
  # setup tmp dir
  tmp_dir="$global_tmp_dir/$pkg"
  mkdir "$tmp_dir"

  # setup status "DB"
  status_dir=$(status_dir_for_package "$pkg")
  mkdir -p "$status_dir"

  last_status=$($debci_bin_dir/debci-status "$pkg")

  log_file="${status_dir}/${run_id}.log"
  status_file="${status_dir}/${run_id}.json"

  # process packages at most once a day -- except if the first attempt failed
  # for some external reason
  if [ -f "$status_file" ]; then
    if [ "$last_status" = 'tmpfail' ]; then
      # find a new run id
      i=1
      local orig_run_id="$run_id"
      while [ -f "$status_file" ]; do
        run_id="${orig_run_id}-${i}"
        log_file="${status_dir}/${run_id}.log"
        status_file="${status_dir}/${run_id}.json"
        i=$(($i + 1))
      done
    else
      return 0 # no need to check for this package
    fi
  fi

  if [ -t 1 ]; then
    # stdout is a tty, show the output and also send it to the log file
    do_process_package 2>&1 | tee "$log_file"
  else
    # running on background, just send everything to the log file
    do_process_package > "$log_file" 2>&1
  fi

  if [ -s "$log_file" ]; then
    ln -sf "${run_id}.log" "${status_dir}/latest.log"
  fi
}


do_process_package() {
  if needs_processing; then
    banner "System information"
    echo "Package versions:"
    dpkg-query --show debci autopkgtest | indent
    echo "Backend: $debci_backend"

    banner "Started: $(date -R)"

    start_time=$(date +%s)

    set +e
    test-package "$pkg"
    exit_status=$?
    set -e

    # ref: adt-run(1)
    case "$exit_status" in
      0)
        status=pass
        message='All tests passed'
        ;;
      2)
        status=pass
        message='Tests passed, but at least one test skipped'
        ;;
      4)
        status=fail
        message='Tests failed'
        ;;
      6)
        status=fail
        message='Tests failed, and at least one test skipped'
        ;;
      *)
        status=tmpfail
        message='Could not run tests due to a temporary failure'
        ;;
    esac
    finish_time=$(date +%s)
    duration=$(($finish_time - $start_time))

    record_status

    banner "Finished: $(date -R)"
  fi
}

has_reasons_to_run=''
reason_for_run() {
  local reason="$*"
  if [ ! $has_reasons_to_run ]; then
    banner "Triggers for test run"
  fi
  echo "$reason"
  has_reasons_to_run=true
}

# XXX this function must not output anything unless there is a need for the
# package to be processed.
needs_processing() {
  check_dependencies > "$tmp_dir/dependencies.txt"

  run=1

  if [ "$last_status" = 'tmpfail' ]; then
    run=0
    reason_for_run "∙ Retrying run since last attempt failed"
  fi

  if [ -n "$cmdline_force" ]; then
    run=0
    reason_for_run "∙ Forced test run for $pkg"
  fi

  if [ -f "${status_dir}/latest.json" -a "${status_dir}/latest.json" -ot "${one_month_ago}" ]; then
    run=0
    reason_for_run '∙ Forcing test run after 1 month without one'
  fi

  if [ -f "$status_dir/dependencies.txt" ]; then
    if diff -u --label last-run/dependencies.txt "$status_dir/dependencies.txt" --label current-run/dependencies.txt "$tmp_dir/dependencies.txt" > "$tmp_dir/dependencies.diff"; then
      : # no need to run tests
    else
      run=0
      reason_for_run "∙ There were changes in the dependency chain since last test run"
      banner "Change in dependency chain for $pkg since last test run"
      cat "$tmp_dir/dependencies.diff"
    fi
  else
    run=0
    reason_for_run "∙ First test run for $pkg"
  fi

  if [ "$run" -eq 0 ]; then
    cp "$tmp_dir/dependencies.txt" "${status_dir}/dependencies.txt"
    banner "Full dependency chain for $pkg at the moment"
    cat "$status_dir/dependencies.txt"
  fi

  return $run
}

check_dependencies() {
  binaries=$(list_binaries "$pkg")
  {
    if ! schroot -d / -c "$debci_chroot_name" -u root -- apt-get install --quiet --assume-yes --simulate $binaries 2>&1; then
      for binary in $binaries; do
        schroot -d / -c "$debci_chroot_name" -u root -- apt-get -q -y --simulate  install $binary 2>&1
      done
    fi
  } | \
    awk '{ if ($1 == "Inst") { sub("^.", "", $3); print($2, $3) } }' | \
    sort | uniq
}

record_status() {
  version=$(check_version "$pkg")

  hours=$(( $duration / 3600 ))
  minutes=$(( ($duration % 3600) / 60 ))
  seconds=$(( $duration - ($hours * 3600) - ($minutes * 60) ))
  duration_human="${hours}h ${minutes}m ${seconds}s"
  banner "Status: $status ($message); duration: ${duration_human}"

  local previous_status="${last_status}"
  if [ "${previous_status}" = 'tmpfail' ]; then
    previous_status=$(debci-status --field previous_status "$pkg")
  fi

  # latest entry
  cat > "${status_file}" <<EOF
{
  "run_id": "${run_id}",
  "package": "${pkg}",
  "version": "${version}",
  "date": "$(date --rfc-3339=seconds)",
  "status": "${status}",
  "previous_status": "${previous_status}",
  "duration_seconds": "${duration}",
  "duration_human": "${duration_human}",
  "message": "${message}"
}
EOF
  ln -sf "${run_id}.json" "$status_dir/latest.json"

  # TODO cleanup old entries (?)

  # history
  history_file="$tmp_dir/history.json"
  echo '[' > "$history_file"
  sep=''
  entries=$(
    find "$status_dir" -name '*.json' \
      -and -not -name latest.json \
      -and -not -name history.json \
      | sort -Vr
  )
  for entry in $entries; do
    if [ -n "$sep" ]; then
      echo "$sep" >> "$history_file"
    fi
    sep=,
    cat $entry >> "$history_file"
  done
  echo ']' >> "$history_file"
  cp "$history_file" "$status_dir/history.json"
}

TEMP=`getopt -o f --long force -- "$@"`

if [ $? != 0 ]; then
  exit 1
fi

eval set -- "$TEMP"

# defaults
cmdline_force=''

while true; do
  case "$1" in
    -f|--force)
      shift
      cmdline_force="yes"
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Internall error ($1)!"
      exit 1
      ;;
  esac
done

if [ $# -eq 1 ]; then
  pkg="$1"
  process_package
else
  echo "usage: $0 [OPTIONS] PACKAGE"
  exit 1
fi
